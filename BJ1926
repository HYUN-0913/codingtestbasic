"""
1. 아이디어
 1) 완전탐색으로 모든 좌표를 탐색하도록 하는 이중for문을 만들고
 2) map가 0이 아니고(1로 색칠), chk에 방문표시 X면 bfs 탐색하도록 함
 3) 탐색을 시작하면 그림의 개수를 하나 증가시킴
 4) 사방 탐색을 이용해 이어져 있는 그림을 찾아내고 크기를 측정함
 5) queue 반복문이 끝나면 현재 가장 큰 그림의 크기와 현재 방문한 그림의 크기를 비교해 값 갱신
2. 시간복잡도
- BFS : O(V+E)
- V : 500 * 500
- E : 대략 V*4(왜냐하면 위아래양옆 방향)= 500 * 500 * 4
- V+E : V+4V= 5*V= 5 * 250000 = 100만 < 2억 >> 가능!
3. 자료구조
- 그래프 전체 지도 : int[][]
- 방문 : bool[][]
- Queue(BFS)
"""

from collections import deque
import sys
input = sys.stdin.readline

n,m = map(int, input().split())
map = [list(map(int, input().split())) for _ in range(n)] #그림정보

chk = [[False] * m for _ in range(n)] #방문여부, m개로된 한줄이 세로로 n개

#(x,y)=>(n,m)=>(세로,가로) => (0,+1):오 (+1,0):아래 (0,-1):왼 (-1,0):위
dx = [0,1,0,-1]# #시계(오른쪽)방향 사방탐색 방법 
dy = [1,0,-1,0]

def bfs(x,y): #사방탐색
    rs = 1 #그림의 최소크기는 1이라, 1로 초기값 설정
    q = deque()
    q.append((x,y)) #q에 넣어줌
    while q: #q가 비어있지 않는 동안 while
        ex, ey= q.popleft() #q에서 꺼냄
        for k in range(4): #4경우 방향에 대해서 한 칸씩 움직여 줌
            nx = ex + dx[k]
            ny = ey + dy[k]
            if 0<=nx<n and 0<=ny<m: #사방탐색의 범위가 그림정보 범위를 넘어가면 X
                if map[nx][ny]== 1 and chk[nx][ny] == False: #0이 아니면서 방문X라면
                    rs += 1
                    chk[nx][ny]= True # BFS중인 이 경우에도 방문여부 O로 처리
                    q.append((nx,ny)) #새로운 (x,y)를 q에 다시 넣어줌-> 빈 q되기 전까지 whie반복
    return rs #(x,y)에 해당하는 그림크기 리턴

cnt = 0 #그림개수
maxv = 0 #최대그림크기

#완전탐색으로 모든 좌표를 탐색하도록 하는 이중for문
for j in range(n): #이중for문은 주로 세로(여기선 n, 더 큰 범위)를 밖에서 돈다
    for i in range(m):
        if map[j][i] == 1 and chk[j][i] == False: #0이 아니면서 방문X면 bfs 탐색하도록 함
            chk[j][i] = True #방문O 표시 갱신
            cnt += 1 #그림개수= bfs호출횟수 임, 1증가
            maxv = max(maxv, bfs(j,i)) #(j,i)와 비교해서 최대그림크기 갱신

#답 출력
print(cnt)
print(maxv)
